### A Pluto.jl notebook ###
# v0.19.9

using Markdown
using InteractiveUtils

# ╔═╡ e2e596e0-fcc8-11ee-2a95-2b0490ab06df
md"""
# Sooyoung Kim's Think Julia 

![image](https://github.com/kimsooyoung/ThinkJulia/assets/12381733/260603e2-20ed-428e-b15b-0381f73fb46c)
"""

# ╔═╡ d0e7ba49-6828-4f55-b704-a30bcc4c2079
md"""
## Iteration (반복)

이번 챕터에서는 반복 키워드인 while에 대해서 배워봅니다. 사실 이전 챕터 4에서 for-loop, 챕터 5에서 재귀를 통한 반복문을 배운 바 있습니다.

비슷한 유형의 반복문인데 왜 굳이 3가지 종류가 있어야 할까요? 그만큼 프로그래밍에서 반복이 자주 사용되고, 프로그램들 자체가 조건을 가진 반복으로 구성되어 있기 때문입니다.

반복문까지 마무리하면 이론적으로 여러분은 그 어떠한 문제도 프로그래밍으로 구현할 수 있습니다. 이것에 대해 궁금하다면 [튜링 완전](https://ko.wikipedia.org/wiki/%ED%8A%9C%EB%A7%81_%EC%99%84%EC%A0%84)에 대해 찾아보세요!
"""

# ╔═╡ 357fbabc-bf4c-49d4-adbe-92026e5491ad
md"""
#### 7.1 Reassignment and Updating (재할당과 갱신)
"""

# ╔═╡ 05a60bc6-2e23-4266-99ca-cfd0242d9c12
md"""
while문을 배우기 전, while과 함께 자주 사용되는 구문을 먼저 알아보고 넘어갈까 합니다. 아래 퀴즈를 한번 풀어보세요!

!!! correct "Quiz"
	아래 코드의 결과를 예측해 보세요
	```juila
	a = 3
	b = a
	a = 4
	@show b
	```
"""

# ╔═╡ 259ae0b1-74df-4b7f-a060-d82d64c29337
md"""
!!! hint "정답"
	> b = 3
	b = a이므로 a가 바뀌면 b도 바뀌어야 할 것 같지만 julia에서 한 번 할당된 변수는 독립적으로 자신의 값을 저장합니다. 따라서 a가 바뀌어도 b는 이전 a의 값인 3을 담고 있게 되지요.
"""

# ╔═╡ 89a454ca-3d22-4729-83c3-3196f55eed6e
md"""
이러한 이유로 변수값의 재할당을 구현하는 것은 항상 조심해야 합니다.
"""

# ╔═╡ 89875980-6088-4ade-80ec-1e8b856eb0f5
md"""
> 다음으로, **변수의 갱신**에 대해 알아보겠습니다. 

개인적으로 매우 자주 사용하는 구문으로 특히 반복문과 함께 사용됩니다. 예시를 살펴보겠습니다.
"""

# ╔═╡ c4669b73-9bd5-4016-bd33-05b1882e6609
begin
	x = 0
	x = x + 1
	@show x
	x += 1
	@show x

	y = 0
	y = y - 1
	@show y
	y -= 1
	@show y

	z = 1
	z = z * 3
	@show z
	z *= 3
	@show z
end

# ╔═╡ 17ba035e-899d-4614-96b8-f39377782885
md"""
위 예시와 같이 `sth = sth + 1` 혹은 `sth += 1`의 구문으로 현재 변수에 1을 갱신하는 작업을 구현 가능합니다. 예를 들어 아래와 같이 for loop와 함께 사용될 수 있습니다. 
"""

# ╔═╡ 9694a4b6-7ad5-4faa-9ba1-5e491799717e
begin
	is_even = 0
	for i in 1:10
		if i % 2 == 0
			is_even += 1
		end
	end
	println("is_even : ", is_even)
end

# ╔═╡ 026679c6-fa51-4327-832f-b2d78e602c57
md"""
#### 7.2 while 문
"""

# ╔═╡ 02bb096a-06ce-4cf4-b40c-4ec8e001692b
md"""
반복되는 계산과 말로 표현하기 어려운 일련의 작업들을 프로그래밍을 통해 자동화하는 것이 바로 우리가 프로그래밍을 배우는 이유일 것입니다.

for, 재귀 함수와 더불어 Julia 프로그램에서 매우 자주 사용되는 while문을 배워봅시다.
"""

# ╔═╡ cd845302-6c41-451f-8f0b-13e14870211e
md"""
이미 배운 적 있는 재귀함수를 사용한 **countdown** 함수를 while로 다시 구현한 예시입니다. 코드를 읽어보면서 while 문법에 대해 한 번 스스로 생각해보세요!

!!! notes "\"recursion style\" vs \"while style\" countdown"
	* recursion style countdown 
	```julia
	function countdown(n)
		if n ≤ 0
			println("Boom!!")
		else
			print("$n ")
			countdown(n-1)
		end
	end
	```
	* while style countdown

	```julia
	function countdown(n)
	    while n > 0
	        print("$n ")
	        n = n - 1
	    end
	    println("Blastoff!")
	end
	```
"""

# ╔═╡ 4137b3f3-3f4f-4483-9cfd-f47d4938c3d1
md"""
while문의 흐름은 다음과 같이 이루어집니다.

1. while 바로 다음 등장하는 조건이 참인지 거짓인지 확인합니다.
2. 조건이 거짓이라면, while문을 벗어나고 그 뒤의 코드를 실행합니다.
3. 조건이 참이라면, while문 내부의 코드를 실행하고 다시 1단계로 돌아갑니다.

1단계의 조건식 때문에, while문에서는 예시의 **n**과 같은 특정 변수를 사용하고 while문 내부에 이 변수의 값을 변화시키는 식으로 구현이 이루어집니다. 챕터 초반 변수의 재할당과 갱신을 배운 이유이지요.
"""

# ╔═╡ 19728c24-d180-4e4b-b0bd-e8c4d1090c8b
md"""
또다른 예시를 하나 더 살펴보겠습니다.
"""

# ╔═╡ 477d2e92-ab58-44ca-a115-0fd9cc815c6d
function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n is even
            n = n / 2
        else                 # n is odd
            n = n*3 + 1
        end
    end
end

# ╔═╡ 4f1bf5ac-b8a9-473a-910c-8473fa8c0b47
seq(3)

# ╔═╡ 00da9941-7e2f-4bbc-b6d5-e368eb81cb8c
md"""
이는 "콜라츠 추측"이라는 문제로 모든 양의 정수 n에 대해서 2로 나누는 작업과 3을 곱하고 1을 더하는 위 작업을 반복하면 결국 1이 된다는 문제입니다.

**결국 1이 되는가?** 라는 조건을 while문의 종료 조건으로 삼고, 기타 작업들을 내부에 구현해둔 상황이지요.
"""

# ╔═╡ a12d81cf-73ac-468c-8ccf-655a31766bc9
md"""
#### 7.3 break 문
"""

# ╔═╡ 9bb35337-5d52-4ff0-a4c6-9d6056154fa2
md"""
while의 흐름 3단계를 다시 읽어봅시다.
> "조건이 참이라면, while문 **내부의 코드를 실행하고** 다시 1단계로 돌아갑니다."
이 뜻은 다시 조건문을 만나기 전까지는 꼼짝없이 내부의 코드를 모두 실행해야 한다는 뜻이기도 합니다.

while문 내부에서 사용할 수 있는 **break**는 예외적으로 while 내부를 벗어나게 해주는 키워드입니다. 
"""

# ╔═╡ 9715db59-9352-444b-9e98-ee27e5faa999
begin
	n = 0
	while true
		n += 1
		if n == 32
			break
		end
	end
end

# ╔═╡ 76943d44-9bac-4521-b45e-728c736e553a
md"""
위 코드와 같이 while의 조건식에 true를 입력하여 **무한 while loop**를 만들고, break와 if를 사용하여 탈출 조건을 구현하는 형태의 구현도 자주 사용합니다. 두 방식 모두 자주 사용하지만 while + true 조합을 사용할 시 탈출조건을 깜박한다면 심각한 에러로 발전할 수 있음을 유념합니다.
"""

# ╔═╡ c8157d0c-0e3d-4184-be3d-3af46029f0ff
md"""
#### 7.4 continue 문
"""

# ╔═╡ b913e10c-effa-4fe8-9f6f-a27582bd607d
md"""
while의 흐름 3을 저지하는 또다른 방식으로 **continue** 문법이 있습니다. continue는 break와 같이 흐름의 중간을 가로채지만 while를 벗어나지는 않고 곧바로 **다음 step의 흐름 1로 이동시킨다**는 의미를 갖고 있습니다.
"""

# ╔═╡ e6482381-09c2-4fb9-877f-ecdc93e2527f
begin
	i = 0
	while true
		i += 1
	    if i % 3 == 0
	        continue
		elseif i >= 10
			break
	    end
	    print(i, " ")
	end
end

# ╔═╡ f01b67ff-f584-4f49-88da-9eb854fbe9fe
md"""
continue 키워드는 for-loop 내부에서도 사용할 수 있습니다.
"""

# ╔═╡ c0cb4882-5765-42f3-8c6c-04c2389c24ed
for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end

# ╔═╡ 56c74872-c033-4b17-a91b-8a0a36c5b686
md"""
#### 7.5 구현 예시 - 제곱근 구하기
"""

# ╔═╡ d930a063-4f5e-4f21-9d00-f0dc01538ad9
md"""
**제곱근**은 어떤 수에 대해서 제곱을 하여 그 수가 나오게 하는 수를 말합니다. 예를 들어 4의 제곱근은 2이고, 9의 제곱근은 3이지요.

2나 3의 제곱근은 소수점 계산을 해야 하기에 구하기 쉽지 않지만 [뉴턴 방법](https://en.wikipedia.org/wiki/Newton%27s_method)이라는 것을 통해 점진적으로 제곱근을 구할 수 있습니다.
"""

# ╔═╡ 13c503ce-bbd6-48f5-b962-c8b2092b3337
md"""
어떠한 수 $a$의 제곱근을 구하고 싶고, 제곱근에 가까운 수 $x$를 알고 있을 때, 아래의 식을 계산하면 기존의 추정치 $x$보다 좀 더 정확한 제곱근 $y$를 얻을 수 있습니다.

${y = \frac{1}{2}\left(x + \frac{a}{x}\right)}$
"""

# ╔═╡ b946bb2e-81b2-47ac-946f-e78506623301
md"""
아래는 4의 제곱근을 구하고 싶고, 추정치는 3인 경우의 예시입니다.
"""

# ╔═╡ 998233c5-6be4-4092-9820-94193233fde5
let 
	a = 4
	x = 3
	y = (x + a/x) / 2
	@show y

	a = 4
	x = y
	y = (x + a/x) / 2
	@show y

	a = 4
	x = y
	y = (x + a/x) / 2
	@show y
end

# ╔═╡ 0731e524-2b70-4e56-9a3d-d675123b7f67
md"""
계산을 반복할수록 실제 제곱근인 2에 점차 가까워지는 것을 알 수 있지요. 

이 반복되는 과정을 while loop를 통해 구현해봅시다. 
"""

# ╔═╡ e5ab3906-6ffd-4f49-bcd4-b69942e6ca7b
function newton_sqrt(a, x)
	ϵ = 0.00001
	while true
		y = (x + a/x) / 2
		if abs(x - y) < ϵ
			return y
		else
			x = y
		end
	end
end

# ╔═╡ 2dd6205f-4901-4d98-8507-ec0b4d5aab6c
newton_sqrt(4, 3)

# ╔═╡ 3b504377-72f5-4400-a276-10597071a07f
md"""
return을 통해 무한 while loop을 벗어나도록 구현한 코드이며 탈출 조건은 **x와 y의 차이 절댓값이 아주 작은 수인 ϵ보다 작을 때**입니다.

컴퓨터에서 소수를 표현함에 있어 약간의 수치적인 오차가 발생할 수 있습니다. 따라서 `x == y`라는 조건은 소수점 가장 끝자리 하나의 차이도 허락하지 않기에 위와 같은 구현이 많이 사용됩니다.

!!! note
	특히 newton's method는 [root-finding](https://en.wikipedia.org/wiki/Root-finding_algorithms) 기법으로 아주 보편적이게 사용됩니다.
"""

# ╔═╡ 52127ce4-bae9-400c-8714-7f7b3b796d54
md"""
### 연습 7-1
---

7.5절에서 제곱근을 구하는 루프를 사용하여, 아래와 같은 표를 출력하는 **testsquareroot** 함수를 작성해보세요.

```
a   mysqrt             sqrt               diff
-   ------             ----               ----
1.0 1.0                1.0                0.0
2.0 1.414213562373095  1.4142135623730951 2.220446049250313e-16
3.0 1.7320508075688772 1.7320508075688772 0.0
4.0 2.0                2.0                0.0
5.0 2.23606797749979   2.23606797749979   0.0
6.0 2.449489742783178  2.449489742783178  0.0
7.0 2.6457513110645907 2.6457513110645907 0.0
8.0 2.82842712474619   2.8284271247461903 4.440892098500626e-16
9.0 3.0                3.0                0.0
```

- 첫 번째 열은 a의 값, 
- 두 번째 열은 newton_sqrt로 계산한 제곱근, 
- 세 번째 열은 sqrt로 계산한 제곱근,
- 네 번째 열은 두 수치의 차이의 절댓값입니다.

""" 

# ╔═╡ 040abb51-8737-4e80-973b-61ddb6730f9f
md"""
### 연습 7-2
---

수학자 스리니바사 라마누잔은 $\frac{1}{\pi}$의 근삿값을 생성하는 무한급수를 찾아냈습니다.


$\begin{equation} {\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}} \end{equation}$

이 공식을 사용해서 \pi의 근삿값을 반환하는 함수 **estimatepi**를 작성해보세요. 

while 문을 이용해 수열의 마지막 항이 1e-15(줄리아에서 $10^{-15}$를 표현하는 방법입니다)보다 작아질 때까지 루프를 돌며 수열의 합을 계산해야 합니다. 계산한 값을 줄리아에 내장된 상수인 $\pi$와 비교해보세요.

""" 

# ╔═╡ Cell order:
# ╟─e2e596e0-fcc8-11ee-2a95-2b0490ab06df
# ╟─d0e7ba49-6828-4f55-b704-a30bcc4c2079
# ╟─357fbabc-bf4c-49d4-adbe-92026e5491ad
# ╟─05a60bc6-2e23-4266-99ca-cfd0242d9c12
# ╟─259ae0b1-74df-4b7f-a060-d82d64c29337
# ╟─89a454ca-3d22-4729-83c3-3196f55eed6e
# ╟─89875980-6088-4ade-80ec-1e8b856eb0f5
# ╠═c4669b73-9bd5-4016-bd33-05b1882e6609
# ╟─17ba035e-899d-4614-96b8-f39377782885
# ╠═9694a4b6-7ad5-4faa-9ba1-5e491799717e
# ╟─026679c6-fa51-4327-832f-b2d78e602c57
# ╟─02bb096a-06ce-4cf4-b40c-4ec8e001692b
# ╟─cd845302-6c41-451f-8f0b-13e14870211e
# ╟─4137b3f3-3f4f-4483-9cfd-f47d4938c3d1
# ╟─19728c24-d180-4e4b-b0bd-e8c4d1090c8b
# ╠═477d2e92-ab58-44ca-a115-0fd9cc815c6d
# ╠═4f1bf5ac-b8a9-473a-910c-8473fa8c0b47
# ╟─00da9941-7e2f-4bbc-b6d5-e368eb81cb8c
# ╟─a12d81cf-73ac-468c-8ccf-655a31766bc9
# ╟─9bb35337-5d52-4ff0-a4c6-9d6056154fa2
# ╠═9715db59-9352-444b-9e98-ee27e5faa999
# ╟─76943d44-9bac-4521-b45e-728c736e553a
# ╟─c8157d0c-0e3d-4184-be3d-3af46029f0ff
# ╟─b913e10c-effa-4fe8-9f6f-a27582bd607d
# ╠═e6482381-09c2-4fb9-877f-ecdc93e2527f
# ╟─f01b67ff-f584-4f49-88da-9eb854fbe9fe
# ╠═c0cb4882-5765-42f3-8c6c-04c2389c24ed
# ╟─56c74872-c033-4b17-a91b-8a0a36c5b686
# ╟─d930a063-4f5e-4f21-9d00-f0dc01538ad9
# ╟─13c503ce-bbd6-48f5-b962-c8b2092b3337
# ╟─b946bb2e-81b2-47ac-946f-e78506623301
# ╠═998233c5-6be4-4092-9820-94193233fde5
# ╟─0731e524-2b70-4e56-9a3d-d675123b7f67
# ╠═e5ab3906-6ffd-4f49-bcd4-b69942e6ca7b
# ╠═2dd6205f-4901-4d98-8507-ec0b4d5aab6c
# ╟─3b504377-72f5-4400-a276-10597071a07f
# ╟─52127ce4-bae9-400c-8714-7f7b3b796d54
# ╟─040abb51-8737-4e80-973b-61ddb6730f9f
